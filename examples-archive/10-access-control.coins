// Example showing access control with decorators
coin AccessControlledCoin {
    storage address owner = xch1jfm8fvqz2wrvc9awwep0awxvuyl2768szpkxjrv575g78hg6ae4swg46g6;
    storage address admin = xch1kzqvtysecmmyvepnhxlw3gnjahq26e9ezwpsf95ucjpl4xufeqds7pgpfu;
    
    event ActionExecuted(string actionName, address caller);
    event OwnershipTransferred(address previousOwner, address newOwner);
    
    // Only owner can execute this action
    @onlyAddress(owner)
    action transferOwnership(address newOwner) {
        require(newOwner != 0x0000000000000000000000000000000000000000000000000000000000000000, "Invalid address");
        
        // In a real implementation, you'd update the owner in state
        // For demonstration, we just emit an event
        emit OwnershipTransferred(owner, newOwner);
    }
    
    // Both owner and admin can execute this action
    @onlyAddress(owner, admin)
    action withdraw(address recipient, uint256 amount) {
        require(amount > 0, "Amount must be positive");
        send(recipient, amount);
        emit ActionExecuted("withdraw", msg.sender);
    }
    
    // Anyone can execute this action (no decorator)
    action publicAction(uint256 value) {
        require(value > 0, "Value must be positive");
        emit ActionExecuted("publicAction", msg.sender);
    }
    
    // Multiple decorators can be combined (future feature)
    @onlyAddress(owner)
    action emergencyStop() {
        // This would pause the contract
        emit ActionExecuted("emergencyStop", msg.sender);
    }
} 