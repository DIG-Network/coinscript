Thanks for confirming. I’ll now create an implementation guide for Layer 2 of the project, which will serve as the driver code that interacts with Layer 1 to construct and sign spend bundles locally.

This guide will:

* Integrate fully with the existing Layer 1 puzzle builder structure
* Include signature operations (e.g., BLS signing)
* Focus on local, offline construction of spend bundles
* Leverage existing npm packages where appropriate (e.g., for CLVM evaluation and spend bundle serialization)
* Define a clear module structure and API for spend management, coin representation, and bundle building

I’ll follow up shortly with the complete specification.


# Layer 2: Driver Code Implementation Guide

## Overview

Layer 2 is the **driver code layer** that builds on Layer 1 (the puzzle builder) to create and sign spend bundles. In Chia’s model, a **spend bundle** is essentially a transaction: it groups one or more coin spends (each with a coin, its puzzle, and a solution) plus an aggregated BLS signature. This layer’s purpose is to take the puzzle programs from Layer 1, combine them with coin data and solutions, and produce a valid spend bundle ready to be submitted to the blockchain. We focus strictly on **local** spend bundle creation and signing, meaning all operations (puzzle assembly, condition generation, signature computation) occur within this project using available libraries, without requiring a running node or external service.

**Key tasks in Layer 2 include:** gathering the coin information, obtaining the puzzle reveal from Layer 1 (and currying in any required parameters, like public keys), constructing the solution conditions (e.g. creating new coins, fees, etc.), and generating the necessary BLS signatures to satisfy the puzzle’s `AGG_SIG_ME` conditions. By using the Chia provided JavaScript/TypeScript libraries for CLVM and BLS, the driver code can operate with high-level abstractions (Program objects, key objects, etc.) and ensure that the spend bundle is correctly formed and cryptographically signed.

## Project Structure and Integration

Layer 2 extends the existing project structure from Layer 1. All new driver code is organized under a `driver` directory within `src`, keeping it modular and easy to maintain. Below is the updated structure with Layer 2 components (bold items are directories, and italicized are example files from Layer 1 for context):

* **src/**

  * **puzzles/** – *Layer 1 modules for puzzle building (CLVM smart coin logic)*

    * *`<puzzle_builder_module>.ts`* (e.g., functions to generate or compile CLVM puzzles)
    * *`...`* (other puzzle-related files, CLVM source or compiled hex files)
  * **driver/** – Layer 2 modules for spend bundle creation & signing

    * **keys.ts** – BLS key management and signature operations module
    * **coin.ts** – Coin data structures and coin ID utility module
    * **spend.ts** – Puzzle solution construction and CoinSpend assembly module
    * **bundle.ts** – SpendBundle assembly and aggregated signature handling module
    * **index.ts** – Entry point/orchestrator that ties everything together (uses the above modules and Layer 1 puzzles to produce spend bundles)
  * *index.ts* – (Optional main script at project root, or this could be the driver `index.ts` mentioned above)

Other standard project files remain in place: e.g. **package.json** (listing dependencies like chia BLS library, CLVM library, etc.), **tsconfig.json**, and possibly a **.env** file for configuration (such as storing a mnemonic or network constants). The Layer 2 code leverages existing NPM packages to avoid reinventing the wheel – for example, using `bls-signatures` (Chia BLS cryptography), `clvm-lib` (to handle CLVM Programs), and Chia’s RPC/wallet libraries for types and helpers. This structure ensures a clear separation: Layer 1 focuses on puzzle logic, and Layer 2 focuses on using those puzzles to perform real coin spends.

## Driver Layer Modules and Responsibilities

### Key Management and Signing (`keys.ts`)

This module handles all aspects of BLS key management and digital signatures:

* **Mnemonic to Key Derivation:** Loads the user's mnemonic (e.g. from an environment variable in `.env`) and converts it to a seed using BIP39. From the seed, it derives the master BLS private key using Chia’s BLS library. For example, `PrivateKey.fromSeed(mnemonicToSeedSync(mnemonic))` will produce the master `PrivateKey`. It can also derive child keys if needed (for multiple addresses), though a single key may suffice for basic cases.
* **Public Key Access:** Exposes the corresponding BLS public key (G1 element) which will be used in puzzles. The public key can be retrieved via the BLS library (e.g. `privateKey.getG1()` to get a G1Element) and provided to Layer 1’s puzzle builder for currying into puzzles. This ensures the puzzle knows which key is authorized to sign the spend.
* **Message Signing:** Provides a function `signMessage(privateKey, message)` that returns a BLS signature on the given message. Under the hood it uses the augmented BLS scheme: e.g. `AugSchemeMPL.sign(sk, message)` from the `bls-signatures` library. In the context of a spend, the message that needs signing will be the *hash of the spend’s conditions combined with the coin’s ID and the network genesis challenge* (as required by `AGG_SIG_ME`). The module helps construct this message correctly and signs it with the appropriate private key. For example, if using the Chia library utilities, it might do: `AugSchemeMPL.sign(sk, concatBytes(conditionsHash, coinId, genesisChallenge))`. The output signature (a G2 element) can be serialized to hex for inclusion in the spend bundle.
* **Signature Aggregation:** If multiple signatures are needed (e.g. spending multiple coins with different keys), the module can aggregate them into a single signature. Chia’s BLS supports non-interactive aggregation – the module uses `AugSchemeMPL.aggregate([...signatures...])` to combine signatures into one. The result is an **aggregated\_signature** that is as compact as a single signature but validates all required messages at once. This aggregated signature will be attached to the spend bundle, satisfying all `AGG_SIG_ME` conditions present.

By centralizing these in a keys module, the rest of the driver code can simply call `keys.getPublicKey()` to curry puzzles or `keys.signCoinSpend(coinSpend, genesis)` to get a signature, without dealing with low-level details each time. This module leverages the Chia **BLS library** for cryptography and the **BIP39** library for mnemonic handling (both are listed as project dependencies).

### Coin Model and Utilities (`coin.ts`)

This module defines the data models for coins and provides utilities needed to identify coins and link them with puzzles:

* **Coin Structure:** Defines a `Coin` object with properties like `parent_id`, `puzzle_hash`, and `amount` (in mojos). This corresponds to an unspent coin on the blockchain. We need these fields to calculate the coin’s ID and to rebuild the coin if needed.
* **Coin ID Calculation:** Implements a utility to compute a coin’s unique ID (also known as CoinID or coin name). In Chia, the coin ID is the hash of the coin’s `parent_id` (the ID of the coin that created it), its `puzzle_hash`, and its `amount`. The module can compute this by concatenating those fields in bytes and hashing (SHA-256). For convenience, we can use the helper from Chia’s libraries – for example, the `toCoinId(coin)` function from `chia-rpc` – which returns the 32-byte coin ID given a coin object. This ID is essential when creating the signature message for `AGG_SIG_ME` conditions, since the coin ID is part of the message that gets signed (tying the signature to that specific coin spend).
* **CoinSpend Definition:** Defines a structure or class `CoinSpend` that combines a `Coin` with the corresponding `puzzle_reveal` and `solution`. In a spend bundle, each entry is such a CoinSpend. The `puzzle_reveal` is the full serialized puzzle program (usually obtained from Layer 1 and possibly curried with specific values like keys), and the `solution` is the serialized CLVM program that the user provides to satisfy the puzzle. By packaging these together with the coin itself, we have all information needed to validate a coin spend.
* **Data Helpers:** (Optional) This module may also include helper functions to format or parse coin-related data. For instance, if coin records come from a JSON source, a function to construct a `Coin` object from JSON, or to convert puzzle hashes from/bech32 addresses if needed. These helpers ensure the driver can interface with inputs/outputs easily (though for strictly offline usage, coin info might be provided directly).

By using this module, the driver code can create `Coin` and `CoinSpend` instances without duplicating logic. For example, when preparing to spend a coin, one would instantiate a `Coin` (with known parent, puzzle hash, amount), then call a function here to get its `coinId` (for signing purposes), and later assemble a `CoinSpend` with the puzzle and solution.

### Puzzle Solution Builder (`spend.ts`)

This module is responsible for constructing the **solution** for a given puzzle (from Layer 1) and preparing the CoinSpend for that coin. It acts as a bridge between the puzzle logic and the specifics of the spend:

* **Retrieving Puzzle Reveal:** It uses the puzzle templates from Layer 1. For example, if Layer 1 provided a function or compiled file for a puzzle, this module will load that. In many cases, the puzzle from Layer 1 may need to be *curried* with runtime parameters. A common pattern is currying in the authorized public key to the puzzle (so that only the holder of the corresponding private key can sign to spend it). The spend module will take the public key from the keys module and curry it into the puzzle program (using CLVM utilities like `Program.curry()`) to produce the final `puzzle_reveal` for this coin. This ensures the puzzle is now specific to the user’s key. *(If Layer 1 already outputs a fully curried puzzle for us, we can skip directly to using it.)*
* **Crafting Conditions (Solution):** Based on what the spend is supposed to do, this module creates the list of conditions that will serve as the coin’s **solution**. For a simple spend, this could include a `(51 <target_puzzle_hash> <amount>)` condition to **CREATE\_COIN** sending some or all value to a recipient or change address. If a fee is to be taken, the module can either subtract the fee from the output amount or include a `(52 <fee_amount>)` **RESERVE\_FEE** condition to explicitly reserve a fee for the miner. Additional conditions like time-locks or announcements can be added here if needed by the puzzle logic. The module provides a developer-friendly way to specify outputs and fees, and translates them into the proper Chialisp condition list.
* **Using CLVM Libraries:** To ensure the solution is encoded correctly, this module leverages the CLVM library. For example, it can use `Program.fromSource(...)` to build a CLVM list program from a human-readable string of conditions. In practice, it might take a list of `(condition_code, args...)` tuples or a preformatted string and convert it into a `Program` object representing the solution. Then it will serialize this Program to bytes/hex (as `SerializedProgram`) to include in the CoinSpend. The result is the `solution` for the coin’s spend.
* **Assembling CoinSpend:** Finally, the module returns a `CoinSpend` object (likely using the class from `coin.ts`). This object includes the coin being spent, the `puzzle_reveal` (the serialized curried puzzle program from Layer 1), and the `solution` (the serialized conditions program we just built). At this stage, no signature is attached yet – we have the spend data prepared, but it’s not authorized until we sign it in the next step. By separating this assembly, the logic of what conditions we want (business logic of the spend) is handled here, while the signature is handled later.

The spend builder thus hides the complexity of CLVM structure from the rest of the code. A developer can call something like `buildCoinSpend(coin, targetAddress, amount, fee)` and get back a ready-to-go CoinSpend. Internally, this would: get the puzzle (curried with pubkey), form the `(CREATE_COIN ... )` and `(RESERVE_FEE ...)` conditions as needed, and package everything. This separation ensures Layer 2 remains *developer-friendly*: you describe what you want to happen with the coin, and the module creates the low-level solution for you.

### Spend Bundle Assembly (`bundle.ts`)

This module takes one or more `CoinSpend` objects and produces a final **SpendBundle** that can be submitted to the blockchain. It coordinates with the keys module to sign each spend and aggregates signatures:

* **Collecting CoinSpends:** It provides functions to add one or multiple CoinSpend entries that should go into the same transaction. For example, if a payment requires spending two coins (perhaps to sum up to the needed amount), both CoinSpend objects (from `spend.ts`) would be fed into this module.
* **Computing Required Signatures:** For each CoinSpend, the module determines what needs to be signed. In our case (puzzles using `AGG_SIG_ME`), each spend’s puzzle will output a required message hash that must be signed by the coin’s key. This message is the SHA-256 tree hash of the coin’s solution (the conditions list), and because it’s `AGG_SIG_ME`, the coin’s ID and the network’s genesis challenge are **concatenated** or included in the signature check. The bundle module uses the coin utility to get the `coinId`, obtains the `conditionsHash` (tree hash of the solution Program), and knows the (constant) `genesis_challenge` for the network (which could be configured or passed in). It then calls `keys.signMessage()` with `message = sha256(conditions || coinId || genesis)` for each CoinSpend. Each resulting signature (G2 element) corresponds to one coin’s spend authorization.
* **Aggregating Signatures:** If there is more than one CoinSpend (or if a single CoinSpend puzzle required multiple signatures, e.g. a multi-sig puzzle), the module will aggregate all the individual signatures into a single **aggregated\_signature**. It uses the BLS library’s aggregation as described earlier, so that the final SpendBundle has just one compact signature that covers all spends. From a verification standpoint, this one signature is valid for all (pubkey, message) pairs required by the spends. The module likely has a helper like `aggregateSignatures(signatures[])` which simply calls the BLS combine function and returns the aggregated signature (perhaps as a hex string or BLS object).
* **Building the SpendBundle:** Finally, the module constructs the `SpendBundle` data structure. In TypeScript, this might be an interface or class matching Chia’s expected format: an object with a `coin_spends` array and an `aggregated_signature`. Each element of `coin_spends` is one of the CoinSpend objects (with coin, puzzle\_reveal, solution), and `aggregated_signature` is a single signature (likely serialized to hex or byte form). This structure matches the Chia blockchain requirements. The module returns this SpendBundle, which represents a complete transaction that can be submitted. The SpendBundle can be easily serialized to JSON for inspection or sending via RPC. For example, after assembly one could output `JSON.stringify(spendBundle)` and see the coin spends and the big signature included.

In summary, `bundle.ts` takes care of **transaction finalization**: ensuring all pieces are in place and cryptographically signing the bundle. By using this module, a developer can simply provide the coin spends and get back a valid spend bundle object. Internally, it makes sure that for every `AGG_SIG_ME` condition in those spends, there is a corresponding signature in `aggregated_signature`. This design also future-proofs for multiple coins: whether the spend bundle has one coin or several, the process is uniform (sign each and aggregate). The result from this module is ready to be submitted to a full node or further encoded as needed.

## Putting It Together: Example Workflow

Using the above modules, here’s how a developer would create and sign a spend bundle locally, step by step:

1. **Initialize Keys:** Load the mnemonic and derive the keys using `keys.ts`. For example, the driver reads `MNEMONIC` from the environment and calls `mnemonicToSeedSync` + `PrivateKey.fromSeed` to get the master private key. The module can then expose the master public key (or a derived child public key) for puzzle currying.
2. **Prepare Coin and Puzzle:** Identify the coin to spend. In an online scenario, this could come from a wallet or RPC call; offline, it might be pre-determined. You need the coin’s parent ID, puzzle hash, and amount. Using the puzzle builder from Layer 1, retrieve the corresponding puzzle program for this coin’s conditions. For example, if Layer 1 defines a `makePuzzle(pubkey)` function or provides a compiled `.clsp.hex`, use it here. Curry in the public key (from step 1) into the puzzle if not already done, producing the coin’s specific `puzzle_reveal`. Now you have a `Coin` object (coin data from the blockchain) and its puzzle program ready.
3. **Craft the Solution:** Decide how to spend the coin’s value. Use `spend.ts` to build the solution conditions. For instance, if you want to send 100 mojos to a friend’s address (puzzle hash `dest_ph`) and pay a fee of 5 mojos, you would create conditions like `CREATE_COIN dest_ph 100` and `RESERVE_FEE 5`. Call the module function (e.g. `buildSolution(coin, outputs, fee)`) which returns a properly formatted solution Program (CLVM list of those conditions). The module then creates a `CoinSpend` that includes the coin, the `puzzle_reveal` from Layer 1, and the serialized solution.
4. **Create the SpendBundle:** If only one coin is being spent, initialize a new SpendBundle. If multiple coins, gather all their CoinSpends. Use `bundle.ts` to assemble the bundle: pass in the list of CoinSpends. The module will automatically compute each spend’s **conditions tree hash**, get each coin’s ID (using `coin.ts` utility, or `toCoinId`), and retrieve the network genesis challenge (from config). With these, it calls the signing function for each coin’s required message. All signatures are then aggregated into one. The module produces a `SpendBundle` object containing `coin_spends: [ ... ]` and `aggregated_signature: <sig>`.
5. **Signatures and Validation:** The aggregated signature in the spend bundle is the BLS combination of all necessary signatures. Thanks to `AGG_SIG_ME`, each signature is tied to the specific coin and transaction context (via coin ID and genesis challenge). This means the spend bundle is now fully authorized – if you inspect it, you’ll see the puzzle reveal and solution for each coin, and one signature that is valid for all of them. The driver does not need to individually attach signatures to each coin; the single `aggregated_signature` covers them all, which is exactly how Chia’s validation will expect it.
6. **Output/Broadcast:** Since we are focusing on local creation, the final step is typically to output the spend bundle (for example, print it as JSON or write to a file). The spend bundle can later be provided to a Chia full node (via RPC or CLI) to broadcast to the network. For instance, one could call the full node RPC method to push the transaction with this spend bundle data. The spend bundle contains all information a full node needs to validate and add the transaction to the mempool: the coins being spent, the puzzle reveals (CLVM code) and solutions (conditions) for each, and the aggregated signature authorizing the spends. The developer can inspect the spend bundle to ensure it’s correct (e.g., the outputs and fee are as intended, and the signature is present). If everything looks good, it’s ready to be used on-chain.

By following this workflow, Layer 2 driver code provides a clear path from high-level intent (spending coins to certain addresses) to a low-level Chia spend bundle. All cryptographic operations and CLVM details are handled by the supporting modules and libraries, making it friendly for developers. The end result is a fully-formed, signed transaction that extends the puzzle logic from Layer 1 into real network actions. This modular design allows easy extension — for example, adding support for multi-signature puzzles or additional conditions would involve updates in the puzzle (Layer 1) and corresponding handling in Layer 2’s spend builder and key management (to gather multiple keys/signatures), without altering the overall architecture of the project. Each layer thus remains cohesive: Layer 1 defines the rules of spending, and Layer 2 executes those rules to create actual spend bundles in a secure (offline-capable) manner.

**Sources:** The implementation relies on Chia’s official libraries and documentation for correctness. The spend bundle format and aggregation behavior are based on Chia Network’s specifications. The signing process adheres to the `AGG_SIG_ME` requirement, including coin IDs and the genesis challenge in the signature message. By using the proven `bls-signatures` library and CLVM utilities, the driver code ensures compatibility with Chia’s consensus and provides a developer-friendly interface for crafting transactions.
